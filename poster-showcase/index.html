<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Poster Showcase</title>
  <link rel="icon" type="image/svg+xml" href="../assets/mediux.svg" />
  <style>
  @import url('https://fonts.googleapis.com/css2?family=Gabarito:wght@400;600;700&display=swap');
  </style>  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
  body {
    margin: 0;
    font-family: 'Gabarito', sans-serif;
    background: linear-gradient(135deg, #000000, #1a0033);
    color: white;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    padding: 1rem 2rem;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    position: relative;
    z-index: 10;
  }
  .header-left {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    position: absolute;
    left: 2rem;
  }
  .header-left h1 {
    font-size: 1.5rem;
    margin: 0;
    color: white;
  }
  .header-center {
    display: flex;
    justify-content: center;
  }
  .poster-tools-brand {
    height: 60px;
    filter: drop-shadow(0 0 6px rgba(0,255,255,0.5));
    transform: translateX(140px);
  }
  .layout {
    display: flex;
    flex: 1;
    overflow: hidden;
  }
  .sidebar {
    width: 280px;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(6px);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
    padding: 1.5rem;
    border-right: 1px solid rgba(255, 255, 255, 0.05);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    box-sizing: border-box;
  }
  .sidebar label {
    font-size: 0.85rem;
    color: #ccc;
  }
  .sidebar input,
  .sidebar select {
    width: 100%;
    max-width: 100%;
    padding: 0.5rem;
    font-size: 0.9rem;
    background: #333;
    color: white;
    border: none;
    border-radius: 6px;
    box-sizing: border-box;
  }
  .sidebar input[type="range"] {
    appearance: none;
    width: 100%;
    height: 4px;
    background: #555;
    border-radius: 4px;
    outline: none;
    margin: 0.4rem 0;
  }
  .sidebar input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 2px black;
  }
  .sidebar button {
    padding: 0.6rem;
    border-radius: 6px;
    border: none;
    background: white;
    color: black;
    font-weight: bold;
    cursor: pointer;
  }
  #resetBtn {
    background: #ff4d4d;
    color: white;
    font-weight: bold;
  }
  .drop-zone {
    border: 2px dashed #ccc;
    padding: 1rem;
    text-align: center;
    border-radius: 8px;
    cursor: pointer;
  }
  #export-bg-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 0;
    overflow: hidden;
    border-radius: 12px;
    margin: 0;
    padding: 0;
  }
  #export-background-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }
  #export-wrapper > *:not(#export-bg-container) {
    position: relative;
    z-index: 1;
  }
  .main {
    flex: 1;
    overflow-y: auto;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 2rem;
  }
  #export-wrapper {
    --bg-start: #2c3e50;
    --bg-end: #6a11cb;
    background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
    padding: 2rem;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: auto;
    max-width: 100%;
    box-sizing: border-box;
    gap: 1rem;
    box-shadow: 0 0 12px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 1;
    border: none;
    outline: none;
    overflow: hidden;
  }
  #logo-preview {
    max-height: 100px;
    display: none;
  }
  .section-title {
    font-size: 1.4rem;
    font-weight: 600;
    color: #fff;
    margin: 0.5rem 0 0.5rem 0;
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.25);
  }
  .grid-section {
    display: flex;
    justify-content: center;
    width: 100%;
  }
  .row {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 14px;
    flex-wrap: nowrap;
  }
  .season-header {
    font-size: 1.1rem;
    font-weight: bold;
    margin-top: 0.25rem;
	margin-bottom: 0.4rem;
    align-self: flex-start;
    width: 100%;
    text-align: left;
    padding-left: 10px;
    color: white;
    text-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
  }
  .poster-wrapper, .titlecard-wrapper {
    width: 200px;
    position: relative;
  }
  .poster, .titlecard {
    width: 100%;
    border-radius: 6px;
    object-fit: cover;
    box-shadow: 0 0 10px rgba(0,0,0,0.4);
  }
  .delete-btn {
    background: red;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    position: absolute;
    top: 4px;
    right: 4px;
    font-size: 1.2rem;
    cursor: pointer;
  }
  .credit-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    font-size: 0.9rem;
    text-shadow: 0 0 4px black;
    margin-top: 1rem;
  }
  .credit-line img {
    height: 22px;
  }
  .created-by {
    display: flex;
    align-items: center;
    gap: 1px;
  }
  .powered-by {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #creator-icon {
    height: 40px;
    width: 40px;
    object-fit: contain;
    border-radius: 8px;
    display: none;
  }
  .powered-by img {
    height: 26px;
    width: 26px;
	margin-bottom: -0.2rem;
  }
  .set-id-line {
    font-size: 0.9rem;
    text-shadow: 0 0 4px black;
  }
  #custom-confirm-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #custom-confirm-modal {
    background: #1a1a1a;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    padding: 20px 25px;
    width: 320px;
    text-align: center;
    color: white;
  }
  .custom-confirm-buttons button {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    margin: 0 5px;
  }
  #confirmYes { background: #ff4d4d; color: white; }
  #confirmNo { background: #ccc; color: #111; }
  input[type="file"] {
    display: none;
  }
  </style>
</head>
<body>
  
  <header>
    <div class="header-left">
      <img src="../assets/mediux.svg" alt="Site Icon" height="28" />
      <h1>Poster Showcase</h1>
	</div>
	<div class="header-center">
	  <a href="../index.html">
	    <img src="../assets/logo.png" alt="Poster Tools Logo" class="poster-tools-brand" />
	  </a>
	</div>
 </header>

  <div class="layout">
    <div class="sidebar">
      <label for="creator-name">Creator Name</label>
      <input type="text" id="creator-name" placeholder="Name Here" />
	  
	  <label for="creator-icon-upload" class="drop-zone">Upload Creator Icon</label>
      <input type="file" id="creator-icon-upload" accept="image/*">

      <label for="set-id">Set ID</label>
      <input type="text" id="set-id" placeholder="e.g. 01" />
	  
	  <label for="bg-image-upload" class="drop-zone">Upload Background Image</label>
      <input type="file" id="bg-image-upload" accept="image/*">

      <label for="columns-select">Posters Per Row</label>
      <select id="columns-select">
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>

      <label for="titlecard-columns-select">Titlecards Per Row</label>
      <select id="titlecard-columns-select">
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>

      <label for="logo-scale">Logo Scale</label>
      <input type="range" id="logo-scale" min="0.3" max="2" step="0.1" value="1">

      <label for="bg-start">Background Start</label>
      <input type="color" id="bg-start" value="#2c3e50">

      <label for="bg-end">Background End</label>
      <input type="color" id="bg-end" value="#6a11cb">

      <label for="logo-upload" class="drop-zone">Upload Clear Logo</label>
      <input type="file" id="logo-upload" accept="image/*" />

      <label for="file-input" class="drop-zone">Upload Posters</label>
      <input type="file" id="file-input" multiple accept="image/*" />

      <label for="titlecard-input" class="drop-zone">Upload Titlecards</label>
      <input type="file" id="titlecard-input" multiple accept="image/*" />

      <button id="downloadBtn">Download Poster Wall</button>
      <button id="resetBtn">Reset Form</button>
    </div>

    <div class="main">
      <div id="export-wrapper">
	    <div id="export-bg-container">
          <img id="export-background-image" />
        </div>
        <img id="logo-preview" alt="Clear Logo" />

        <h2 class="section-title">Posters</h2>
        <div id="poster-grid-wrapper" class="grid-section">
          <div id="poster-grid"></div>
        </div>

        <hr style="width: 100%; border-color: rgba(255,255,255,0.2);">

        <h2 class="section-title">Titlecards</h2>
        <div id="titlecard-grid-wrapper" class="grid-section">
          <div id="titlecard-grid"></div>
        </div>

        <div class="set-id-line" id="set-id-line"></div>
        <div class="credit-line">
          <div class="created-by" id="created-by">
            <img id="creator-icon" src="" alt="Creator Icon" />
            <span>Created by <span id="credit-text"></span></span>
          </div>
          <div class="powered-by">
            <span>Powered by mediux.pro</span>
            <img src="../assets/mediux.svg" alt="Mediux Icon" />
          </div>
        </div>
      </div>
    </div>
  </div>
		
  <div id="custom-confirm-overlay">
    <div id="custom-confirm-modal">
      <p>Are you sure you want to reset the form? You will lose all current uploads and settings.</p>
      <div class="custom-confirm-buttons">
        <button id="confirmYes">Yes</button>
        <button id="confirmNo">No</button>
      </div>
    </div>
  </div>

<script>
document.getElementById("creator-icon-upload").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (evt) => {
      const icon = document.getElementById("creator-icon");
      icon.src = evt.target.result;
      icon.style.display = "inline-block";
    };
    reader.readAsDataURL(file);
  }
});

document.getElementById("creator-name").addEventListener("input", e => {
  document.getElementById("credit-text").textContent = e.target.value;
});
	
const posterGrid = document.getElementById("poster-grid");
const titlecardGrid = document.getElementById("titlecard-grid");
const columnsSelect = document.getElementById("columns-select");
const titlecardColumnsSelect = document.getElementById("titlecard-columns-select");
const bgImage = document.getElementById("export-background-image");
let originalBgDataURL = null;

function groupIntoRows(items, perRow) {
  const rows = [];
  for (let i = 0; i < items.length; i += perRow) {
    const row = document.createElement("div");
    row.className = "row";
    row.append(...items.slice(i, i + perRow));
    rows.push(row);
  }
  return rows;
}

function renderGrid(container, items, perRow) {
  container.innerHTML = "";
  groupIntoRows(items, perRow).forEach(row => container.appendChild(row));
}

function collectItems(gridClass) {
  return [...document.querySelectorAll(`.${gridClass}`)].map(el => el.closest(`.${gridClass}-wrapper`));
}

function groupItemsWithHeaders(container, perRow) {
  const elements = Array.from(container.querySelectorAll('.season-header, .titlecard-wrapper'));
  container.innerHTML = '';

  let currentRow = null, count = 0;

  elements.forEach((el, index) => {
    if (el.classList.contains('season-header')) {
      if (currentRow && currentRow.children.length > 0) {
        container.appendChild(currentRow);
        currentRow = null;
        count = 0;
      }
      
      // Add divider before every header except the first one
      if (index !== 0) {
        const divider = document.createElement('hr');
        divider.style.cssText = 'width: 100%; border-color: rgba(255,255,255,0.2); margin: 10px 0;';
        container.appendChild(divider);
      }

      container.appendChild(el);
    } else {
      if (!currentRow || count >= perRow) {
        if (currentRow) container.appendChild(currentRow);
        currentRow = document.createElement('div');
        currentRow.className = 'row';
        count = 0;
      }
      currentRow.appendChild(el);
      count++;
    }
  });

  if (currentRow && currentRow.children.length > 0) {
    container.appendChild(currentRow);
  }
}

function rebuildGrids() {
  const posterItems = collectItems("poster");
  renderGrid(posterGrid, posterItems, parseInt(columnsSelect.value));

  groupItemsWithHeaders(titlecardGrid, parseInt(titlecardColumnsSelect.value));
}

function createImageElement(src, className) {
  const wrapper = document.createElement("div");
  wrapper.className = `${className}-wrapper`;
  const img = document.createElement("img");
  img.src = src;
  img.className = className;
  img.draggable = true;

  const btn = document.createElement("button");
  btn.className = "delete-btn";
  btn.textContent = "×";
  btn.onclick = () => {
    wrapper.remove();
    rebuildGrids();
  };

  wrapper.appendChild(img);
  wrapper.appendChild(btn);
  img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
  img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
  wrapper.addEventListener("dragover", e => e.preventDefault());
  wrapper.addEventListener("drop", e => {
    e.preventDefault();
    const dragging = document.querySelector("[data-dragging]");
    if (dragging && dragging !== wrapper) {
      wrapper.parentNode.insertBefore(dragging.closest(`.${className}-wrapper`), wrapper);
      rebuildGrids();
    }
  });

  return wrapper;
}

async function handleFiles(files, className) {
  const fileArray = [...files];

  if (className === "poster") {
    fileArray.sort((a, b) => {
      const normalize = name => name.toLowerCase().replace(/\.[^/.]+$/, "").trim();
      const getSortKey = (filename) => {
        const name = normalize(filename.name);
        const seasonMatch = name.match(/ - season (\d{1,3})$/i);
        const baseName = name.replace(/ - season \d{1,3}$/i, "");
        const seasonNumber = seasonMatch ? parseInt(seasonMatch[1], 10) : -1;
        return { baseName, seasonNumber };
      };
      const aKey = getSortKey(a);
      const bKey = getSortKey(b);
      if (aKey.baseName !== bKey.baseName) {
        return aKey.baseName.localeCompare(bKey.baseName);
      }
      return aKey.seasonNumber - bKey.seasonNumber;
    });
  }

  if (className === "titlecard") {
    const parseInfo = name => {
      const cleaned = name.toLowerCase().replace(/\.[^/.]+$/, "").trim();
      const match = cleaned.match(/s(\d{1,2})[\s\.]?e(\d{1,2})/i);
      const season = match ? parseInt(match[1], 10) : 0;
      const episode = match ? parseInt(match[2], 10) : 0;
      return { name, season, episode };
    };

    const container = document.querySelector(`#${className}-grid`);

    // Extract existing titlecards first
    const existingWrappers = Array.from(container.querySelectorAll('.titlecard-wrapper'));
    const existingCards = existingWrappers.map(wrapper => ({
      src: wrapper.querySelector('img').src,
      season: parseInt(wrapper.dataset.season),
      episode: parseInt(wrapper.dataset.episode),
    }));

    // Process new uploaded titlecards
    const newCards = await Promise.all(fileArray.map(async file => {
      const src = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(file);
      });
      const {season, episode} = parseInfo(file.name);
      return {src, season, episode};
    }));

    // Merge and sort existing + new titlecards
    const allCards = [...existingCards, ...newCards].sort((a, b) =>
      a.season - b.season || a.episode - b.episode
    );

    // Clear container for fresh regrouping
    container.innerHTML = '';

    let currentSeason = null;

    // Rebuild titlecards with headers
    allCards.forEach(card => {
      if (card.season !== currentSeason) {
        currentSeason = card.season;
        const heading = document.createElement("div");
        heading.className = "season-header";
        heading.textContent = `Season ${String(card.season).padStart(2, '0')}`;
        container.appendChild(heading);
      }

      const wrapper = document.createElement("div");
      wrapper.className = "titlecard-wrapper";
      wrapper.dataset.season = card.season;
      wrapper.dataset.episode = card.episode;

      const img = document.createElement("img");
      img.src = card.src;
      img.className = "titlecard";
      img.draggable = true;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "×";
      btn.onclick = () => {
        wrapper.remove();
        rebuildGrids();
      };

      wrapper.appendChild(img);
      wrapper.appendChild(btn);

      img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
      img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
      wrapper.addEventListener("dragover", e => e.preventDefault());
      wrapper.addEventListener("drop", e => {
        e.preventDefault();
        const dragging = document.querySelector("[data-dragging]");
        if (dragging && dragging !== wrapper) {
          wrapper.parentNode.insertBefore(dragging.closest('.titlecard-wrapper'), wrapper);
          rebuildGrids();
        }
      });

      container.appendChild(wrapper);
    });

    // Final regroup into rows
    groupItemsWithHeaders(container, parseInt(titlecardColumnsSelect.value));

  } else {
    // For posters (original logic remains)
    const container = document.querySelector(`#${className}-grid`);
    container.innerHTML = "";

    const wrappers = await Promise.all(fileArray.map(async file => {
      const result = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(file);
      });

      const wrapper = document.createElement("div");
      wrapper.className = `${className}-wrapper`;

      const img = document.createElement("img");
      img.src = result;
      img.className = className;
      img.draggable = true;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "×";
      btn.onclick = () => {
        wrapper.remove();
        rebuildGrids();
      };

      wrapper.appendChild(img);
      wrapper.appendChild(btn);

      img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
      img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
      wrapper.addEventListener("dragover", e => e.preventDefault());
      wrapper.addEventListener("drop", e => {
        e.preventDefault();
        const dragging = document.querySelector("[data-dragging]");
        if (dragging && dragging !== wrapper) {
          wrapper.parentNode.insertBefore(dragging.closest(`.${className}-wrapper`), wrapper);
          rebuildGrids();
        }
      });

      return wrapper;
    }));

    wrappers.forEach(wrapper => container.appendChild(wrapper));
    rebuildGrids();
  }
}

document.getElementById("bg-image-upload").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (evt) => {
    const dataURL = evt.target.result;
    originalBgDataURL = dataURL;

    // Load the image to ensure it's valid
    const testImg = new Image();
    testImg.onload = () => {
      bgImage.src = dataURL;
      bgImage.style.display = "block";
      updateBackgroundStyles();
    };
    testImg.onerror = () => {
      console.error("Failed to load background image.");
      bgImage.style.display = "none";
      originalBgDataURL = null;
      updateBackgroundStyles();
    };
    testImg.src = dataURL;
  };
  reader.readAsDataURL(file);

  // Reset input so the same file can be reselected later
  e.target.value = "";
});

document.getElementById("file-input").addEventListener("change", async (e) => {
  await handleFiles(e.target.files, "poster");
});

document.getElementById("titlecard-input").addEventListener("change", async (e) => {
  await handleFiles(e.target.files, "titlecard");
});
columnsSelect.addEventListener("change", rebuildGrids);
titlecardColumnsSelect.addEventListener("change", rebuildGrids);

document.getElementById("creator-name").addEventListener("input", e => {
  document.getElementById("credit-text").textContent = e.target.value;
});
document.getElementById("set-id").addEventListener("input", e => {
  document.getElementById("set-id-line").textContent = e.target.value ? `Set ID: ${e.target.value}` : "";
});
document.getElementById("logo-scale").addEventListener("input", e => {
  document.getElementById("logo-preview").style.transform = `scale(${e.target.value})`;
});
document.getElementById("logo-upload").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    const img = document.getElementById("logo-preview");
    img.src = evt.target.result;
    img.style.display = "block";
  };
  reader.readAsDataURL(file);
});

document.getElementById("bg-start").addEventListener("input", e => {
  document.getElementById("export-wrapper").style.setProperty("--bg-start", e.target.value);
  updateBackgroundStyles();
});
document.getElementById("bg-end").addEventListener("input", e => {
  document.getElementById("export-wrapper").style.setProperty("--bg-end", e.target.value);
  updateBackgroundStyles();
});

function updateBackgroundStyles() {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgContainer = document.getElementById("export-bg-container");

  if (originalBgDataURL) {
    bgContainer.style.display = "block";
    exportWrapper.style.background = "none"; // override gradient fallback
  } else {
    bgContainer.style.display = "none";
    const bgStart = document.getElementById("bg-start").value;
    const bgEnd = document.getElementById("bg-end").value;
    exportWrapper.style.background = `linear-gradient(135deg, ${bgStart}, ${bgEnd})`;
  }
}

function fixBackgroundContainerSizing() {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgContainer = document.getElementById("export-bg-container");
  
  if (exportWrapper && bgContainer) {
    // Make sure the background container completely fills the wrapper
    bgContainer.style.position = "absolute";
    bgContainer.style.top = "0";
    bgContainer.style.left = "0";
    bgContainer.style.right = "0";
    bgContainer.style.bottom = "0";
    bgContainer.style.overflow = "hidden";
    bgContainer.style.borderRadius = "12px"; // Match wrapper's border radius
    bgContainer.style.margin = "0"; // Remove any margin
    
    // Make sure any white borders or outlines are removed
    exportWrapper.style.border = "none";
    exportWrapper.style.outline = "none";
    exportWrapper.style.overflow = "hidden"; // Prevent content from spilling out
  }
}

// Call these functions on page load
fixBackgroundContainerSizing();
updateBackgroundStyles();

// Also call after relevant changes
window.addEventListener("resize", fixBackgroundContainerSizing);

document.getElementById("resetBtn").addEventListener("click", () => {
  const overlay = document.getElementById('custom-confirm-overlay');
  const confirmYes = document.getElementById('confirmYes');
  const confirmNo = document.getElementById('confirmNo');

  overlay.style.display = 'flex';

  confirmYes.onclick = () => location.reload();
  confirmNo.onclick = () => overlay.style.display = 'none';
});
document.getElementById("downloadBtn").addEventListener("click", async () => {
  const wrapper = document.getElementById("export-wrapper");
  const originalBg = originalBgDataURL; // Custom background image
  const borderRadius = 24; // Border radius value in pixels (for export)
  
  // Clone the wrapper to avoid modifying the actual DOM
  const clone = wrapper.cloneNode(true);
  clone.querySelectorAll(".delete-btn").forEach(btn => btn.remove());
  
  clone.style.borderRadius = `${borderRadius}px`;
  clone.style.overflow = "hidden";
  clone.style.background = getComputedStyle(wrapper).background;

  const cloneExportWrapper = clone.querySelector("#export-wrapper");
  if (cloneExportWrapper) {
    cloneExportWrapper.style.borderRadius = `${borderRadius}px`;
    cloneExportWrapper.style.overflow = "hidden";
    cloneExportWrapper.style.background = getComputedStyle(wrapper).background;
  }
  
  // Remove bg container so html2canvas won't include it
  const bgContainer = clone.querySelector("#export-bg-container");
  if (bgContainer) bgContainer.remove();

  // Remove titlecard section if empty
  const titlecardGridClone = clone.querySelector("#titlecard-grid");
  if (!titlecardGridClone || titlecardGridClone.children.length === 0) {
    const sectionTitle = clone.querySelector(".section-title:nth-of-type(2)");
    const wrapper = clone.querySelector("#titlecard-grid-wrapper");
    if (sectionTitle) sectionTitle.remove();
    if (wrapper) wrapper.remove();
  }

  clone.style.position = "absolute";
  clone.style.left = "-9999px";
  clone.style.borderRadius = `${borderRadius}px`;
  clone.style.overflow = "hidden";
  document.body.appendChild(clone);

  await new Promise(requestAnimationFrame); // wait for DOM paint

  // Capture the main content area using html2canvas
  const contentCanvas = await html2canvas(clone, {
    scale: 2,
    backgroundColor: null // Set backgroundColor to null to prevent background from being rendered by html2canvas
  });

  document.body.removeChild(clone);

  // Create final canvas to draw both background and content
  const finalCanvas = document.createElement("canvas");
  finalCanvas.width = contentCanvas.width;
  finalCanvas.height = contentCanvas.height;
  const ctx = finalCanvas.getContext("2d");

  // Scale border radius for canvas (since we're using scale 2)
  const scaledRadius = borderRadius * 2;
  
  // Helper function to draw rounded rectangle path
  function roundedRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    return ctx;
  }

  // Create rounded rectangle clipping path
  roundedRect(ctx, 0, 0, finalCanvas.width, finalCanvas.height, scaledRadius);
  ctx.clip();

  // Step 1: Draw the custom background if available
  if (originalBg) {
    const bgImg = new Image();
    await new Promise((resolve, reject) => {
      bgImg.onload = resolve;
      bgImg.onerror = reject;
      bgImg.src = originalBg;
    });

    // Draw the background image onto the final canvas (with clipping applied)
    ctx.drawImage(bgImg, 0, 0, finalCanvas.width, finalCanvas.height);
  } else {
    // Fallback gradient background if no image is uploaded
    const gradient = ctx.createLinearGradient(0, 0, finalCanvas.width, finalCanvas.height);
    gradient.addColorStop(0, getComputedStyle(wrapper).getPropertyValue('--bg-start') || '#2c3e50');
    gradient.addColorStop(1, getComputedStyle(wrapper).getPropertyValue('--bg-end') || '#6a11cb');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
  }
  
  // Step 2: Draw the content (posters, titlecards, etc.) on top of the background
  ctx.drawImage(contentCanvas, 0, 0);
  
  // Step 3: Export as image
  const link = document.createElement("a");
  link.download = "poster-wall.png";
  link.href = finalCanvas.toDataURL("image/png");
  link.click();
});
</script>
</body>
</html>
