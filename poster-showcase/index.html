<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Poster Showcase</title>
  <link rel="icon" type="image/svg+xml" href="../assets/mediux.svg" />
  <style>
  @import url('https://fonts.googleapis.com/css2?family=Gabarito:wght@400;600;700&display=swap');
  </style>  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
  body {
    margin: 0;
    font-family: 'Gabarito', sans-serif;
    background: linear-gradient(135deg, #000000, #1a0033);
    color: white;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    padding: 1rem 2rem;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    position: relative;
    z-index: 10;
  }
  .header-left {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    position: absolute;
    left: 2rem;
  }
  .header-left h1 {
    font-size: 1.5rem;
    margin: 0;
    color: white;
  }
  .header-center {
    display: flex;
    justify-content: center;
  }
  .poster-tools-brand {
    height: 60px;
    filter: drop-shadow(0 0 6px rgba(0,255,255,0.5));
    transform: translateX(140px);
  }
  .layout {
    display: flex;
    flex: 1;
    overflow: hidden;
  }
  .sidebar {
    width: 280px;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(6px);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
    padding: 1.5rem;
    border-right: 1px solid rgba(255, 255, 255, 0.05);
    display: flex;
    flex-direction: column;
    gap: 0.7rem;
    box-sizing: border-box;
    /* Added these properties for scrolling */
    overflow-y: auto;
    max-height: 100%;
    /* Improved scrollbar styling */
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.1);
  }
  /* Scrollbar styling for WebKit browsers (Chrome, Safari, etc.) */
  .sidebar::-webkit-scrollbar {
    width: 8px;
  }
  .sidebar::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
  }
  .sidebar::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
  }
  .sidebar::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.5);
  }
  .sidebar label {
    font-size: 0.85rem;
    color: #ccc;
  }
  .sidebar input,
  .sidebar select {
    width: 100%;
    max-width: 100%;
    padding: 0.5rem;
    font-size: 0.9rem;
    background: #333;
    color: white;
    border: none;
    border-radius: 6px;
    box-sizing: border-box;
  }
  .sidebar input[type="range"] {
    appearance: none;
    width: 100%;
    height: 4px;
    background: #555;
    border-radius: 4px;
    outline: none;
    margin: 0.4rem 0;
  }
  .sidebar input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 2px black;
  }
  .sidebar button {
    padding: 0.6rem;
    border-radius: 6px;
    border: none;
    background: white;
    color: black;
    font-weight: bold;
    cursor: pointer;
  }
  #resetBtn {
    background: #ff4d4d;
    color: white;
    font-weight: bold;
  }
  .drop-zone {
    border: 2px dashed #ccc;
    padding: 1rem;
    text-align: center;
    border-radius: 8px;
    cursor: pointer;
  }
  .drop-zone:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.5);
  }
  #export-bg-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 0;
    overflow: hidden;
    border-radius: 12px;
    margin: 0;
    padding: 0;
	background: linear-gradient(135deg, #2c3e50, #6a11cb);
  }
  #export-background-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
  }
  #export-wrapper > *:not(#export-bg-container) {
    position: relative;
    z-index: 1;
  }
  .main {
    flex: 1;
    overflow-y: auto;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 2rem;
  }
  #export-wrapper {
    --bg-start: #2c3e50;
    --bg-end: #6a11cb;
    background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
	background-clip: padding-box;
    padding: 2rem;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
	min-width: 500px;
    width: auto;
    max-width: 100%;
    box-sizing: border-box;
    gap: 1rem;
    box-shadow: none !important;
	border-color: transparent !important;
    position: relative;
    z-index: 1;
    border: none !important;
    outline: none !important;
    overflow: hidden !important;
  }
  #logo-preview {
    max-height: 100px;
    display: none;
  }
  #backdrop-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 0;
    overflow: hidden;
    border-radius: 12px;
    margin: 0;
    padding: 0;
  }
  #backdrop-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
  }
  .section-title {
    font-size: 1.4rem;
    font-weight: 600;
    color: #fff;
    margin: 0.5rem 0 0.5rem 0;
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.25);
  }
  .grid-section {
    display: flex;
    justify-content: center;
    width: 100%;
  }
  .row {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 14px;
    flex-wrap: nowrap;
  }
  .season-header {
    font-size: 1.1rem;
    font-weight: bold;
    margin-top: 0.25rem;
	margin-bottom: 0.4rem;
    align-self: flex-start;
    width: 100%;
    text-align: left;
    padding-left: 10px;
    color: white;
    text-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
  }
  .poster-wrapper, .titlecard-wrapper {
    width: 200px;
    position: relative;
  }
  .poster, .titlecard {
    width: 100%;
    border-radius: 6px;
    object-fit: cover;
    box-shadow: 0 0 10px rgba(0,0,0,0.4);
  }
  .delete-btn {
    background: red;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    position: absolute;
    top: 4px;
    right: 4px;
    font-size: 1.2rem;
    cursor: pointer;
  }
  .credit-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    font-size: 0.9rem;
    text-shadow: 0 0 4px black;
    margin-top: 1rem;
  }
  .credit-line img {
    height: 22px;
  }
  .created-by {
    display: flex;
    align-items: center;
    gap: 1px;
  }
  .powered-by {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #creator-icon {
    height: 40px;
    width: auto;
    object-fit: contain;
    border-radius: 8px;
    display: none;
  }
  .powered-by img {
    height: 17px;
    width: auto;
	max-width: 100%;
	margin-bottom: -0.1rem;
	object-fit: contain;
  }
  .set-id-line {
    font-size: 0.9rem;
    text-shadow: 0 0 4px black;
  }
  #custom-confirm-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #custom-confirm-modal {
    background: #1a1a1a;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    padding: 20px 25px;
    width: 320px;
    text-align: center;
    color: white;
  }
  .custom-confirm-buttons button {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    margin: 0 5px;
  }
  #confirmYes { background: #ff4d4d; color: white; }
  #confirmNo { background: #ccc; color: #111; }
  input[type="file"] {
    display: none;
  }
  
  /* Toggle switch styling */
  .toggle-container {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 0.25rem;
  }
  
  .toggle-switch {
    position: relative;
    display: inline-block;
    width: 46px;
    height: 24px;
  }
  
  .toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
    margin: 0;
  }
  
  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #444;
    transition: .3s;
    border-radius: 24px;
  }
  
  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .3s;
    border-radius: 50%;
  }
  
  input:checked + .toggle-slider {
    background-color: #0088cc;
  }
  
  input:checked + .toggle-slider:before {
    transform: translateX(22px);
  }
  
  .toggle-label {
    font-size: 0.85rem;
    color: #ccc;
  }
  
  /* Section separator */
  .section-separator {
    width: 100%;
    margin: 0.5rem 0;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    padding-top: 0.5rem;
  }
  
  /* Media query for very small screens */
  @media (max-height: 700px) {
    .sidebar {
      padding-right: 1rem; /* Slightly reduce padding to account for scrollbar */
    }
  }
  </style>
</head>
<body>
  
  <header>
    <div class="header-left">
      <img src="/assets/mediux.svg" alt="Site Icon" height="28" />
      <h1>Poster Showcase</h1>
	</div>
	<div class="header-center">
	  <a href="../index.html">
	    <img src="../assets/logo.png" alt="Poster Tools Logo" class="poster-tools-brand" />
	  </a>
	</div>
 </header>

  <div class="layout">
    <div class="sidebar">
      <label for="creator-name">Creator Name</label>
      <input type="text" id="creator-name" placeholder="Name Here" />
	  
	  <label for="creator-icon-upload" class="drop-zone">Upload Creator Icon</label>
      <input type="file" id="creator-icon-upload" accept="image/*">

      <label for="set-id">Set ID</label>
      <input type="text" id="set-id" placeholder="e.g. 01" />
	  
	  <div class="section-separator"></div>
	  
	  <label for="file-input" class="drop-zone">Upload Posters</label>
      <input type="file" id="file-input" multiple accept="image/*" />

      <label for="titlecard-input" class="drop-zone">Upload Titlecards</label>
      <input type="file" id="titlecard-input" multiple accept="image/*" />

      <label for="logo-upload" class="drop-zone">Upload Clear Logo</label>
      <input type="file" id="logo-upload" accept="image/*" />
	  
	  <label for="logo-scale">Logo Scale</label>
      <input type="range" id="logo-scale" min="0.3" max="2" step="0.1" value="1">
	  
	  <div class="section-separator"></div>
	  
	  <label for="columns-select">Posters Per Row</label>
      <select id="columns-select">
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
      </select>

      <label for="titlecard-columns-select">Titlecards Per Row</label>
      <select id="titlecard-columns-select">
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>
      
      <!-- Section headings toggles -->
      <div class="toggle-container">
        <span class="toggle-label">Show Posters Header</span>
        <label class="toggle-switch">
          <input type="checkbox" id="show-posters-header" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      
      <div class="toggle-container">
        <span class="toggle-label">Show Titlecards Header</span>
        <label class="toggle-switch">
          <input type="checkbox" id="show-titlecards-header" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
	  
	  <div class="section-separator"></div>
	  
	  <label for="backdrop-upload" class="drop-zone">Upload Backdrop</label>
      <input type="file" id="backdrop-upload" accept="image/*">

      <label for="blur-amount">Blur Amount</label>
      <input type="range" id="blur-amount" min="0" max="30" step="1" value="5">
      
      <!-- Background toggle switch -->
      <div class="toggle-container">
        <span class="toggle-label">Use Backdrop</span>
        <label class="toggle-switch">
          <input type="checkbox" id="use-backdrop-toggle" >
          <span class="toggle-slider"></span>
        </label>
      </div>

      <label for="bg-start">Background Start</label>
      <input type="color" id="bg-start" value="#2c3e50">

      <label for="bg-end">Background End</label>
      <input type="color" id="bg-end" value="#6a11cb">

      <div class="section-separator"></div>
      
      <button id="downloadBtn">Download Poster Wall</button>
      <button id="resetBtn">Reset Form</button>
    </div>

    <div class="main">
      <div id="export-wrapper">
	    <div id="export-bg-container">
          <img id="export-background-image" />
        </div>
        <img id="logo-preview" alt="Clear Logo" />

        <h2 class="section-title" id="posters-header">Posters</h2>
        <div id="poster-grid-wrapper" class="grid-section">
          <div id="poster-grid"></div>
        </div>

        <hr style="width: 100%; border-color: rgba(255,255,255,0.2);">

        <h2 class="section-title" id="titlecards-header">Titlecards</h2>
        <div id="titlecard-grid-wrapper" class="grid-section">
          <div id="titlecard-grid"></div>
        </div>

        <div class="set-id-line" id="set-id-line"></div>
        <div class="credit-line">
          <div class="created-by" id="created-by">
            <img id="creator-icon" src="" alt="Creator Icon" />
            <span>Created by <span id="credit-text"></span></span>
          </div>
          <div class="powered-by">
            <span>mediux.pro</span>
            <img src="../assets/mediux.svg" alt="Mediux Icon" />
          </div>
        </div>
      </div>
    </div>
  </div>
		
  <div id="custom-confirm-overlay">
    <div id="custom-confirm-modal">
      <p>Are you sure you want to reset the form? You will lose all current uploads and settings.</p>
      <div class="custom-confirm-buttons">
        <button id="confirmYes">Yes</button>
        <button id="confirmNo">No</button>
      </div>
    </div>
  </div>

<script>
(function initializeStyles() {
  // Set default gradient background immediately
  const exportWrapper = document.getElementById("export-wrapper");
  if (exportWrapper) {
    const bgStart = document.getElementById("bg-start")?.value || "#2c3e50";
    const bgEnd = document.getElementById("bg-end")?.value || "#6a11cb";
    
    // Force the background to be visible
    exportWrapper.style.setProperty("--bg-start", bgStart);
    exportWrapper.style.setProperty("--bg-end", bgEnd);
    exportWrapper.style.background = `linear-gradient(135deg, ${bgStart}, ${bgEnd})`;
    exportWrapper.style.backgroundImage = 'none';
  }
})();
// JavaScript - Full implementation
document.getElementById("creator-icon-upload").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (evt) => {
      const icon = document.getElementById("creator-icon");
      icon.src = evt.target.result;
      icon.style.display = "inline-block";
    };
    reader.readAsDataURL(file);
  }
});

document.getElementById("creator-name").addEventListener("input", e => {
  document.getElementById("credit-text").textContent = e.target.value;
});

// Toggle switches for section headers
document.getElementById("show-posters-header").addEventListener("change", e => {
  document.getElementById("posters-header").style.display = e.target.checked ? "block" : "none";
});

document.getElementById("show-titlecards-header").addEventListener("change", e => {
  document.getElementById("titlecards-header").style.display = e.target.checked ? "block" : "none";
});

document.getElementById("logo-upload").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    const img = document.getElementById("logo-preview");
    img.src = evt.target.result;
    img.style.display = "block";
  };
  reader.readAsDataURL(file);
});

// Toggle for backdrop vs gradient background
document.getElementById("use-backdrop-toggle").addEventListener("change", e => {
  toggleBackgroundType(e.target.checked);
});

document.getElementById("file-input").addEventListener("change", async (e) => {
  await handleFiles(e.target.files, "poster");
});

document.getElementById("titlecard-input").addEventListener("change", async (e) => {
  await handleFiles(e.target.files, "titlecard");
});

function updateGradientBackground() {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgStart = document.getElementById("bg-start").value;
  const bgEnd = document.getElementById("bg-end").value;
  
  console.log("Updating gradient with colors:", bgStart, bgEnd);
  
  // Store values in CSS variables
  exportWrapper.style.setProperty("--bg-start", bgStart);
  exportWrapper.style.setProperty("--bg-end", bgEnd);
  
  // Only update the visible background if backdrop is not active
  if (!document.getElementById("use-backdrop-toggle").checked || !window._currentBackdropURL) {
    // FORCE REDRAW: First completely remove all background properties
    exportWrapper.style.removeProperty('background');
    exportWrapper.style.removeProperty('backgroundImage');
    exportWrapper.style.backgroundColor = 'transparent';
    
    // Force a browser repaint to clear any cached style values
    void exportWrapper.offsetWidth;
    
    // Apply the new gradient style - multiple ways to ensure it takes effect
    const gradientStyle = `linear-gradient(135deg, ${bgStart}, ${bgEnd})`;
    exportWrapper.style.background = gradientStyle;
    exportWrapper.style.backgroundImage = gradientStyle;
    
    // Update the bg-container too in case that's what's being displayed
    const bgContainer = document.getElementById("export-bg-container");
    if (bgContainer) {
      bgContainer.style.background = gradientStyle;
    }
  }
}

function toggleBackgroundType(useBackdrop) {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgImage = document.getElementById("export-background-image");
  
  console.log("Toggle background:", useBackdrop ? "Using backdrop" : "Using gradient");
  console.log("Has backdrop URL:", !!window._currentBackdropURL);
  
  // Hide/show the background image
  if (bgImage) {
    bgImage.style.display = useBackdrop ? "block" : "none";
  }

  // Clear all background styles first for a clean slate
  exportWrapper.style.removeProperty('background');
  exportWrapper.style.backgroundColor = 'transparent';
  exportWrapper.style.backgroundImage = 'none';

  // Force repaint to avoid flickers
  void exportWrapper.offsetWidth;

  if (useBackdrop && window._currentBackdropURL) {
    // Use the backdrop image
    console.log("Applying backdrop URL:", window._currentBackdropURL.substring(0, 50) + "...");
    exportWrapper.style.backgroundImage = `url(${window._currentBackdropURL})`;
    exportWrapper.style.backgroundSize = "cover";
    exportWrapper.style.backgroundPosition = "center";
  } else {
    // Use gradient background
    updateGradientBackground();
  }
}
	
const posterGrid = document.getElementById("poster-grid");
const titlecardGrid = document.getElementById("titlecard-grid");
const columnsSelect = document.getElementById("columns-select");
const titlecardColumnsSelect = document.getElementById("titlecard-columns-select");
const bgImage = document.getElementById("export-background-image");
let originalBgDataURL = null;
let blurredBackdropDataURL = null;
let backdropCanvas = document.createElement('canvas');
let backdropCtx = backdropCanvas.getContext('2d');

function groupIntoRows(items, perRow) {
  const rows = [];
  for (let i = 0; i < items.length; i += perRow) {
    const row = document.createElement("div");
    row.className = "row";
    row.append(...items.slice(i, i + perRow));
    rows.push(row);
  }
  return rows;
}

function renderGrid(container, items, perRow) {
  container.innerHTML = "";
  groupIntoRows(items, perRow).forEach(row => container.appendChild(row));
}

function collectItems(gridClass) {
  return [...document.querySelectorAll(`.${gridClass}`)].map(el => el.closest(`.${gridClass}-wrapper`));
}

function groupItemsWithHeaders(container, perRow) {
  const elements = Array.from(container.querySelectorAll('.season-header, .titlecard-wrapper'));
  container.innerHTML = '';

  let currentRow = null, count = 0;

  elements.forEach((el, index) => {
    if (el.classList.contains('season-header')) {
      if (currentRow && currentRow.children.length > 0) {
        container.appendChild(currentRow);
        currentRow = null;
        count = 0;
      }
      
      // Add divider before every header except the first one
      if (index !== 0) {
        const divider = document.createElement('hr');
        divider.style.cssText = 'width: 100%; border-color: rgba(255,255,255,0.2); margin: 10px 0;';
        container.appendChild(divider);
      }

      container.appendChild(el);
    } else {
      if (!currentRow || count >= perRow) {
        if (currentRow) container.appendChild(currentRow);
        currentRow = document.createElement('div');
        currentRow.className = 'row';
        count = 0;
      }
      currentRow.appendChild(el);
      count++;
    }
  });

  if (currentRow && currentRow.children.length > 0) {
    container.appendChild(currentRow);
  }
}

function rebuildGrids() {
  const posterItems = collectItems("poster");
  renderGrid(posterGrid, posterItems, parseInt(columnsSelect.value));

  groupItemsWithHeaders(titlecardGrid, parseInt(titlecardColumnsSelect.value));
}

function createImageElement(src, className) {
  const wrapper = document.createElement("div");
  wrapper.className = `${className}-wrapper`;
  const img = document.createElement("img");
  img.src = src;
  img.className = className;
  img.draggable = true;

  const btn = document.createElement("button");
  btn.className = "delete-btn";
  btn.textContent = "×";
  btn.onclick = () => {
    wrapper.remove();
    rebuildGrids();
  };

  wrapper.appendChild(img);
  wrapper.appendChild(btn);
  img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
  img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
  wrapper.addEventListener("dragover", e => e.preventDefault());
  wrapper.addEventListener("drop", e => {
    e.preventDefault();
    const dragging = document.querySelector("[data-dragging]");
    if (dragging && dragging !== wrapper) {
      wrapper.parentNode.insertBefore(dragging.closest(`.${className}-wrapper`), wrapper);
      rebuildGrids();
    }
  });

  return wrapper;
}

async function handleFiles(files, className) {
  const fileArray = [...files];

  if (className === "poster") {
    fileArray.sort((a, b) => {
      const normalize = name => name.toLowerCase().replace(/\.[^/.]+$/, "").trim();
      const getSortKey = (filename) => {
        const name = normalize(filename.name);
        const seasonMatch = name.match(/ - season (\d{1,3})$/i);
        const baseName = name.replace(/ - season \d{1,3}$/i, "");
        const seasonNumber = seasonMatch ? parseInt(seasonMatch[1], 10) : -1;
        return { baseName, seasonNumber };
      };
      const aKey = getSortKey(a);
      const bKey = getSortKey(b);
      if (aKey.baseName !== bKey.baseName) {
        return aKey.baseName.localeCompare(bKey.baseName);
      }
      return aKey.seasonNumber - bKey.seasonNumber;
    });
    
    // Extract existing posters first
    const container = document.querySelector(`#${className}-grid`);
    const existingPosters = Array.from(container.querySelectorAll('.poster-wrapper')).map(wrapper => 
      wrapper.querySelector('img').src
    );

    // Process new uploaded posters
    const newPosterSrcs = await Promise.all(fileArray.map(async file => {
      return await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(file);
      });
    }));

    // Merge existing and new posters
    const allPosterSrcs = [...existingPosters, ...newPosterSrcs];
    
    // Clear container and rebuild
    container.innerHTML = "";
    
    // Create wrappers for all posters
    const wrappers = allPosterSrcs.map(src => {
      const wrapper = document.createElement("div");
      wrapper.className = `${className}-wrapper`;

      const img = document.createElement("img");
      img.src = src;
      img.className = className;
      img.draggable = true;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "×";
      btn.onclick = () => {
        wrapper.remove();
        rebuildGrids();
      };

      wrapper.appendChild(img);
      wrapper.appendChild(btn);

      img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
      img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
      wrapper.addEventListener("dragover", e => e.preventDefault());
      wrapper.addEventListener("drop", e => {
        e.preventDefault();
        const dragging = document.querySelector("[data-dragging]");
        if (dragging && dragging !== wrapper) {
          wrapper.parentNode.insertBefore(dragging.closest(`.${className}-wrapper`), wrapper);
          rebuildGrids();
        }
      });

      return wrapper;
    });
    
    wrappers.forEach(wrapper => container.appendChild(wrapper));
    rebuildGrids();
  } 
  else if (className === "titlecard") {
    const parseInfo = name => {
      const cleaned = name.toLowerCase().replace(/\.[^/.]+$/, "").trim();
      const match = cleaned.match(/s(\d{1,2})[\s\.]?e(\d{1,2})/i);
      const season = match ? parseInt(match[1], 10) : 0;
      const episode = match ? parseInt(match[2], 10) : 0;
      return { name, season, episode };
    };

    const container = document.querySelector(`#${className}-grid`);

    // Extract existing titlecards first
    const existingWrappers = Array.from(container.querySelectorAll('.titlecard-wrapper'));
    const existingCards = existingWrappers.map(wrapper => ({
      src: wrapper.querySelector('img').src,
      season: parseInt(wrapper.dataset.season || "0"),
      episode: parseInt(wrapper.dataset.episode || "0"),
    }));

    // Process new uploaded titlecards
    const newCards = await Promise.all(fileArray.map(async file => {
      const src = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(file);
      });
      const {season, episode} = parseInfo(file.name);
      return {src, season, episode};
    }));

    // Merge and sort existing + new titlecards
    const allCards = [...existingCards, ...newCards].sort((a, b) =>
      a.season - b.season || a.episode - b.episode
    );

    // Clear container for fresh regrouping
    container.innerHTML = '';

    let currentSeason = null;

    // Rebuild titlecards with headers
    allCards.forEach(card => {
      if (card.season !== currentSeason) {
        currentSeason = card.season;
        const heading = document.createElement("div");
        heading.className = "season-header";
        heading.textContent = `Season ${String(card.season).padStart(2, '0')}`;
        container.appendChild(heading);
      }

      const wrapper = document.createElement("div");
      wrapper.className = "titlecard-wrapper";
      wrapper.dataset.season = card.season;
      wrapper.dataset.episode = card.episode;

      const img = document.createElement("img");
      img.src = card.src;
      img.className = "titlecard";
      img.draggable = true;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "×";
      btn.onclick = () => {
        wrapper.remove();
        rebuildGrids();
      };

      wrapper.appendChild(img);
      wrapper.appendChild(btn);

      img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
      img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
      wrapper.addEventListener("dragover", e => e.preventDefault());
      wrapper.addEventListener("drop", e => {
        e.preventDefault();
        const dragging = document.querySelector("[data-dragging]");
        if (dragging && dragging !== wrapper) {
          wrapper.parentNode.insertBefore(dragging.closest('.titlecard-wrapper'), wrapper);
          rebuildGrids();
        }
      });

      container.appendChild(wrapper);
    });

    // Final regroup into rows
    groupItemsWithHeaders(container, parseInt(titlecardColumnsSelect.value));
  }
}

document.getElementById("backdrop-upload").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async (evt) => {
    const dataURL = evt.target.result;
    
    try {
      // Store original image data for later use
      const originalImg = new Image();
      originalImg.src = dataURL;
      
      await new Promise(resolve => {
        originalImg.onload = resolve;
      });
      
      window._originalBackdropImage = originalImg;
      
      // Apply blur with current slider value
      const blurAmount = parseInt(document.getElementById("blur-amount").value);
      
      // Auto-check the backdrop toggle when a new backdrop is uploaded
      document.getElementById("use-backdrop-toggle").checked = true;
      
      // Process and apply the backdrop
      applySmartBlur(originalImg, blurAmount);
      
      // Ensure the toggle actually applies the backdrop
      toggleBackgroundType(true);
      
    } catch (error) {
      console.error("Error in backdrop processing:", error);
      alert("There was an error processing your image. Please try another one.");
    }
  };
  
  reader.readAsDataURL(file);
  e.target.value = "";
});

document.getElementById("blur-amount").addEventListener("input", async (e) => {
  if (!window._originalBackdropImage) return;
  
  const blurAmount = parseInt(e.target.value);
  applySmartBlur(window._originalBackdropImage, blurAmount);
});

// Logo scale slider
document.getElementById("logo-scale").addEventListener("input", e => {
  document.getElementById("logo-preview").style.transform = `scale(${e.target.value})`;
});

// Grid column selectors
document.getElementById("columns-select").addEventListener("change", rebuildGrids);
document.getElementById("titlecard-columns-select").addEventListener("change", rebuildGrids);

// Set ID field
document.getElementById("set-id").addEventListener("input", e => {
  document.getElementById("set-id-line").textContent = e.target.value ? `Set ID: ${e.target.value}` : "";
});

// Toggle for backdrop vs gradient background
document.getElementById("use-backdrop-toggle").addEventListener("change", e => {
  toggleBackgroundType(e.target.checked);
});

document.getElementById("bg-start").addEventListener("input", () => {
  updateGradientBackground();
});

document.getElementById("bg-end").addEventListener("input", () => {
  updateGradientBackground();
});

function applySmartBlur(originalImg, blurAmount) {
  // Create a canvas for processing
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas to a reasonable size (not too small to avoid excessive pixelation)
  const scaleFactor = Math.max(0.1, 1 - (blurAmount * 0.03)); // Smoother scale reduction
  
  canvas.width = Math.floor(originalImg.width * scaleFactor);
  canvas.height = Math.floor(originalImg.height * scaleFactor);
  
  // First pass - draw at reduced size (creates initial blur)
  ctx.drawImage(originalImg, 0, 0, canvas.width, canvas.height);
  
  // Apply a CSS-style blur filter if blurAmount is high enough
  if (blurAmount > 5) {
    // This simulates a Gaussian blur
    const blurPx = Math.min(20, blurAmount - 5);
    ctx.filter = `blur(${blurPx}px)`;
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
    ctx.filter = 'none';
  }
  
  // Calculate dimensions with padding to ensure coverage to edges
  const padding = 50; // Add extra padding to ensure full coverage
  
  // Second pass - scale back up with padding
  const finalCanvas = document.createElement('canvas');
  const finalCtx = finalCanvas.getContext('2d');
  
  // Use a size that matches the aspect ratio but is reasonably large
  const maxDimension = Math.max(originalImg.width, originalImg.height);
  const targetSize = Math.min(1920, maxDimension); // Cap at 1920px for performance
  
  let finalWidth, finalHeight;
  if (originalImg.width > originalImg.height) {
    finalWidth = targetSize + padding * 2;
    finalHeight = ((originalImg.height / originalImg.width) * targetSize) + padding * 2;
  } else {
    finalHeight = targetSize + padding * 2;
    finalWidth = ((originalImg.width / originalImg.height) * targetSize) + padding * 2;
  }
  
  finalCanvas.width = finalWidth;
  finalCanvas.height = finalHeight;
  
  // Use better quality interpolation
  finalCtx.imageSmoothingEnabled = true;
  finalCtx.imageSmoothingQuality = "high";
  
  // Draw the blurred image at larger size with padding
  finalCtx.drawImage(canvas, -padding, -padding, finalWidth + padding * 2, finalHeight + padding * 2);
  
  // Add a subtle darkening overlay to make content stand out better
  finalCtx.fillStyle = "rgba(0, 0, 0, 0.2)";
  finalCtx.fillRect(0, 0, finalWidth, finalHeight);
  
  // Apply the blurred image as background
  const blurredDataURL = finalCanvas.toDataURL('image/jpeg', 0.92);
  blurredBackdropDataURL = blurredDataURL;
  window._currentBackdropURL = blurredDataURL;
  
  const bgImage = document.getElementById("export-background-image");
  if (bgImage) {
  bgImage.src = blurredDataURL;
  bgImage.style.display = "block";
  }
  
  // IMPORTANT: Force the backdrop to be immediately visible if toggle is on
  const useBackdrop = document.getElementById("use-backdrop-toggle").checked;
  if (useBackdrop) {
    // Apply to DOM synchronously
    const exportWrapper = document.getElementById("export-wrapper");
    exportWrapper.style.removeProperty('background');
    exportWrapper.style.backgroundColor = 'transparent';
    exportWrapper.style.backgroundImage = 'none';
    
    // Force a repaint
    void exportWrapper.offsetWidth;
    
    // Apply the image immediately
    exportWrapper.style.backgroundImage = `url('${blurredDataURL}')`;
    exportWrapper.style.backgroundSize = "cover";
    exportWrapper.style.backgroundPosition = "center";
    exportWrapper.style.backgroundRepeat = "no-repeat";
    exportWrapper.style.borderRadius = "12px";
    exportWrapper.style.overflow = "hidden";
  }
}

// Toggle switches for section headers
document.getElementById("show-posters-header").addEventListener("change", e => {
  document.getElementById("posters-header").style.display = e.target.checked ? "block" : "none";
});

document.getElementById("show-titlecards-header").addEventListener("change", e => {
  document.getElementById("titlecards-header").style.display = e.target.checked ? "block" : "none";
});

function updateBackgroundStyles() {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgContainer = document.getElementById("export-bg-container");
  const useBackdrop = document.getElementById("use-backdrop-toggle").checked;

  // If we have a blurred backdrop and the toggle is enabled
  if (window._currentBackdropURL && useBackdrop) {
    bgContainer.style.display = "none";
    exportWrapper.style.removeProperty('background');
    exportWrapper.style.background = 'none';
    exportWrapper.style.backgroundImage = `url(${window._currentBackdropURL})`;
    exportWrapper.style.backgroundSize = "cover";
    exportWrapper.style.backgroundPosition = "center";
  } else {
    // Use gradient background
    bgContainer.style.display = "none";
    const bgStart = document.getElementById("bg-start").value;
    const bgEnd = document.getElementById("bg-end").value;
    
    // Clear background image first
    exportWrapper.style.backgroundImage = 'none';
    
    // Then set the gradient
    exportWrapper.style.background = `linear-gradient(135deg, ${bgStart}, ${bgEnd})`;
  }
}

document.getElementById("resetBtn").addEventListener("click", () => {
  const overlay = document.getElementById('custom-confirm-overlay');
  const confirmYes = document.getElementById('confirmYes');
  const confirmNo = document.getElementById('confirmNo');

  overlay.style.display = 'flex';

  confirmYes.onclick = () => location.reload();
  confirmNo.onclick = () => overlay.style.display = 'none';
});

document.getElementById("downloadBtn").addEventListener("click", async () => {
  const wrapper = document.getElementById("export-wrapper");
  const borderRadius = 24; // Border radius value in pixels (for export)
  
  // Check for blurred backdrop and if toggle is enabled
  const useBackdrop = document.getElementById("use-backdrop-toggle").checked;
  const hasBlurredBackdrop = window._currentBackdropURL && useBackdrop ? true : false;
  const originalBg = originalBgDataURL; // Custom background image
  
  // Clone the wrapper to avoid modifying the actual DOM
  const clone = wrapper.cloneNode(true);
  clone.querySelectorAll(".delete-btn").forEach(btn => btn.remove());
  
  // Set proper styles for the clone
  clone.style.borderRadius = `${borderRadius}px`;
  clone.style.overflow = "hidden";
  
  // IMPORTANT: Completely strip background from clone - we'll draw it manually
  clone.style.background = "none";
  clone.style.backgroundColor = "transparent";
  clone.style.backgroundImage = "none";
  
  // Also clean the export-wrapper inside the clone
  const cloneExportWrapper = clone.querySelector("#export-wrapper");
  if (cloneExportWrapper) {
    cloneExportWrapper.style.borderRadius = `${borderRadius}px`;
    cloneExportWrapper.style.overflow = "hidden";
    cloneExportWrapper.style.background = "none";
    cloneExportWrapper.style.backgroundColor = "transparent";
    cloneExportWrapper.style.backgroundImage = "none";
  }
  
  // Remove ALL background containers from clone
  const bgContainerClone = clone.querySelector("#export-bg-container");
  if (bgContainerClone) bgContainerClone.remove();
  
  const backdropContainerClone = clone.querySelector("#backdrop-container");
  if (backdropContainerClone) backdropContainerClone.remove();

  // Check section visibility based on toggle states
  const showPostersHeader = document.getElementById("show-posters-header").checked;
  const showTitlecardsHeader = document.getElementById("show-titlecards-header").checked;
  
  // Handle section headers visibility for export
  const postersHeaderClone = clone.querySelector("#posters-header");
  const titlecardsHeaderClone = clone.querySelector("#titlecards-header");
  
  if (postersHeaderClone) {
    postersHeaderClone.style.display = showPostersHeader ? "block" : "none";
  }
  
  if (titlecardsHeaderClone) {
    titlecardsHeaderClone.style.display = showTitlecardsHeader ? "block" : "none";
  }
  
  // Remove titlecard section if empty
  const titlecardGridClone = clone.querySelector("#titlecard-grid");
  if (!titlecardGridClone || titlecardGridClone.children.length === 0) {
    if (titlecardsHeaderClone) titlecardsHeaderClone.remove();
    const wrapper = clone.querySelector("#titlecard-grid-wrapper");
    if (wrapper) wrapper.remove();
  }

  // Position clone off-screen for rendering
  clone.style.position = "absolute";
  clone.style.left = "-9999px";
  document.body.appendChild(clone);

  await new Promise(requestAnimationFrame); // wait for DOM paint

  // Capture ONLY the content (no background)
  const contentCanvas = await html2canvas(clone, {
    scale: 2,
    backgroundColor: null, // Transparent background is crucial
    logging: false,
    onclone: (document) => {
      // Double-ensure no backgrounds on any elements
      const exportWrapper = document.getElementById("export-wrapper");
      if (exportWrapper) {
        exportWrapper.style.background = "none";
        exportWrapper.style.backgroundColor = "transparent";
        exportWrapper.style.backgroundImage = "none";
      }
    }
  });

  document.body.removeChild(clone);

  // Create final canvas with correct dimensions
  const finalCanvas = document.createElement("canvas");
  finalCanvas.width = contentCanvas.width;
  finalCanvas.height = contentCanvas.height;
  const ctx = finalCanvas.getContext("2d");

  // Apply rounded corners via clipping path
  const scaledRadius = borderRadius * 2;
  ctx.beginPath();
  ctx.moveTo(scaledRadius, 0);
  ctx.lineTo(finalCanvas.width - scaledRadius, 0);
  ctx.quadraticCurveTo(finalCanvas.width, 0, finalCanvas.width, scaledRadius);
  ctx.lineTo(finalCanvas.width, finalCanvas.height - scaledRadius);
  ctx.quadraticCurveTo(finalCanvas.width, finalCanvas.height, finalCanvas.width - scaledRadius, finalCanvas.height);
  ctx.lineTo(scaledRadius, finalCanvas.height);
  ctx.quadraticCurveTo(0, finalCanvas.height, 0, finalCanvas.height - scaledRadius);
  ctx.lineTo(0, scaledRadius);
  ctx.quadraticCurveTo(0, 0, scaledRadius, 0);
  ctx.closePath();
  ctx.clip();

  // Step 1: Draw the appropriate background covering the ENTIRE canvas
  if (hasBlurredBackdrop) {
    // Use blurred backdrop
    const bgImg = new Image();
    await new Promise((resolve, reject) => {
      bgImg.onload = resolve;
      bgImg.onerror = reject;
      bgImg.src = window._currentBackdropURL;
    });

    // Fill the entire canvas with the blurred backdrop
    ctx.drawImage(bgImg, 0, 0, finalCanvas.width, finalCanvas.height);
    
    // Add slight darkening overlay for better contrast with content
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
    ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
  }
  else if (originalBg) {
    // Use regular background image
    const bgImg = new Image();
    await new Promise((resolve, reject) => {
      bgImg.onload = resolve;
      bgImg.onerror = reject;
      bgImg.src = originalBg;
    });

    ctx.drawImage(bgImg, 0, 0, finalCanvas.width, finalCanvas.height);
  } else {
    // Fallback to gradient
    const gradient = ctx.createLinearGradient(0, 0, finalCanvas.width, finalCanvas.height);
    gradient.addColorStop(0, getComputedStyle(wrapper).getPropertyValue('--bg-start') || '#2c3e50');
    gradient.addColorStop(1, getComputedStyle(wrapper).getPropertyValue('--bg-end') || '#6a11cb');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
  }
  
  // Step 2: Draw the content (posters, titlecards, etc.) on top
  ctx.drawImage(contentCanvas, 0, 0);
  
  // Step 3: Export as image
  const link = document.createElement("a");
  link.download = "poster-wall.png";
  link.href = finalCanvas.toDataURL("image/png");
  link.click();
});

window.addEventListener('DOMContentLoaded', () => {
  // Set the gradient as default background
  const exportWrapper = document.getElementById("export-wrapper");
  const bgStart = document.getElementById("bg-start").value;
  const bgEnd = document.getElementById("bg-end").value;
  exportWrapper.style.background = `linear-gradient(135deg, ${bgStart}, ${bgEnd})`;
  exportWrapper.style.backgroundImage = 'none';
});
</script>
</body>
</html>
