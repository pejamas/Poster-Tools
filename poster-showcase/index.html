<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Poster Showcase</title>
  <link rel="icon" type="image/svg+xml" href="../assets/mediux.svg" />
  <style>
  @import url('https://fonts.googleapis.com/css2?family=Gabarito:wght@400;600;700&display=swap');
  </style>  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style>
  body {
    margin: 0;
    font-family: 'Gabarito', sans-serif;
    background: linear-gradient(135deg, #000000, #1a0033);
    color: white;
    display: flex;
    flex-direction: column;
    height: 100vh;
  }
  header {
    padding: 1rem 2rem;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(8px);
    position: relative;
    z-index: 10;
  }
  .header-left {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    position: absolute;
    left: 2rem;
  }
  .header-left h1 {
    font-size: 1.5rem;
    margin: 0;
    color: white;
  }
  .header-center {
    display: flex;
    justify-content: center;
  }
  .poster-tools-brand {
    height: 60px;
    filter: drop-shadow(0 0 6px rgba(0,255,255,0.5));
    transform: translateX(140px);
  }
  .layout {
    display: flex;
    flex: 1;
    overflow: hidden;
  }
  .sidebar {
    width: 280px;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(6px);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.1);
    padding: 1.5rem;
    border-right: 1px solid rgba(255, 255, 255, 0.05);
    display: flex;
    flex-direction: column;
    gap: 1rem;
    box-sizing: border-box;
    /* Added these properties for scrolling */
    overflow-y: auto;
    max-height: 100%;
    /* Improved scrollbar styling */
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.1);
  }
  /* Scrollbar styling for WebKit browsers (Chrome, Safari, etc.) */
  .sidebar::-webkit-scrollbar {
    width: 8px;
  }
  .sidebar::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.1);
    border-radius: 4px;
  }
  .sidebar::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
  }
  .sidebar::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.5);
  }
  .sidebar label {
    font-size: 0.85rem;
    color: #ccc;
  }
  .sidebar input,
  .sidebar select {
    width: 100%;
    max-width: 100%;
    padding: 0.5rem;
    font-size: 0.9rem;
    background: #333;
    color: white;
    border: none;
    border-radius: 6px;
    box-sizing: border-box;
  }
  .sidebar input[type="range"] {
    appearance: none;
    width: 100%;
    height: 4px;
    background: #555;
    border-radius: 4px;
    outline: none;
    margin: 0.4rem 0;
  }
  .sidebar input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 16px;
    height: 16px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 2px black;
  }
  .sidebar button {
    padding: 0.6rem;
    border-radius: 6px;
    border: none;
    background: white;
    color: black;
    font-weight: bold;
    cursor: pointer;
  }
  #resetBtn {
    background: #ff4d4d;
    color: white;
    font-weight: bold;
  }
  .drop-zone {
    border: 2px dashed #ccc;
    padding: 1rem;
    text-align: center;
    border-radius: 8px;
    cursor: pointer;
  }
  .drop-zone:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.5);
  }
  #export-bg-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 0;
    overflow: hidden;
    border-radius: 12px;
    margin: 0;
    padding: 0;
  }
  #export-background-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }
  #export-wrapper > *:not(#export-bg-container) {
    position: relative;
    z-index: 1;
  }
  .main {
    flex: 1;
    overflow-y: auto;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 2rem;
  }
  #export-wrapper {
    --bg-start: #2c3e50;
    --bg-end: #6a11cb;
    background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
    padding: 2rem;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: auto;
    max-width: 100%;
    box-sizing: border-box;
    gap: 1rem;
    box-shadow: 0 0 12px rgba(0, 0, 0, 0.3);
    position: relative;
    z-index: 1;
    border: none;
    outline: none;
    overflow: hidden;
  }
  #logo-preview {
    max-height: 100px;
    display: none;
  }
  #backdrop-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 0;
    overflow: hidden;
    border-radius: 12px;
    margin: 0;
    padding: 0;
  }
  #backdrop-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
  }
  .section-title {
    font-size: 1.4rem;
    font-weight: 600;
    color: #fff;
    margin: 0.5rem 0 0.5rem 0;
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.25);
  }
  .grid-section {
    display: flex;
    justify-content: center;
    width: 100%;
  }
  .row {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 14px;
    flex-wrap: nowrap;
  }
  .season-header {
    font-size: 1.1rem;
    font-weight: bold;
    margin-top: 0.25rem;
	margin-bottom: 0.4rem;
    align-self: flex-start;
    width: 100%;
    text-align: left;
    padding-left: 10px;
    color: white;
    text-shadow: 0 0 4px rgba(0, 0, 0, 0.4);
  }
  .poster-wrapper, .titlecard-wrapper {
    width: 200px;
    position: relative;
  }
  .poster, .titlecard {
    width: 100%;
    border-radius: 6px;
    object-fit: cover;
    box-shadow: 0 0 10px rgba(0,0,0,0.4);
  }
  .delete-btn {
    background: red;
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    position: absolute;
    top: 4px;
    right: 4px;
    font-size: 1.2rem;
    cursor: pointer;
  }
  .credit-line {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    font-size: 0.9rem;
    text-shadow: 0 0 4px black;
    margin-top: 1rem;
  }
  .credit-line img {
    height: 22px;
  }
  .created-by {
    display: flex;
    align-items: center;
    gap: 1px;
  }
  .powered-by {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #creator-icon {
    height: 40px;
    width: 40px;
    object-fit: contain;
    border-radius: 8px;
    display: none;
  }
  .powered-by img {
    height: 26px;
    width: 26px;
	margin-bottom: -0.2rem;
  }
  .set-id-line {
    font-size: 0.9rem;
    text-shadow: 0 0 4px black;
  }
  #custom-confirm-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }
  #custom-confirm-modal {
    background: #1a1a1a;
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    padding: 20px 25px;
    width: 320px;
    text-align: center;
    color: white;
  }
  .custom-confirm-buttons button {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    margin: 0 5px;
  }
  #confirmYes { background: #ff4d4d; color: white; }
  #confirmNo { background: #ccc; color: #111; }
  input[type="file"] {
    display: none;
  }
  
  /* Media query for very small screens */
  @media (max-height: 700px) {
    .sidebar {
      padding-right: 1rem; /* Slightly reduce padding to account for scrollbar */
    }
  }
  </style>
</head>
<body>
  
  <header>
    <div class="header-left">
      <img src="/assets/mediux.svg" alt="Site Icon" height="28" />
      <h1>Poster Showcase</h1>
	</div>
	<div class="header-center">
	  <a href="../index.html">
	    <img src="../assets/logo.png" alt="Poster Tools Logo" class="poster-tools-brand" />
	  </a>
	</div>
 </header>

  <div class="layout">
    <div class="sidebar">
      <label for="creator-name">Creator Name</label>
      <input type="text" id="creator-name" placeholder="Name Here" />
	  
	  <label for="creator-icon-upload" class="drop-zone">Upload Creator Icon</label>
      <input type="file" id="creator-icon-upload" accept="image/*">

      <label for="set-id">Set ID</label>
      <input type="text" id="set-id" placeholder="e.g. 01" />
	  
	  <label for="backdrop-upload" class="drop-zone">Upload Backdrop</label>
      <input type="file" id="backdrop-upload" accept="image/*">

      <label for="blur-amount">Blur Amount</label>
      <input type="range" id="blur-amount" min="0" max="30" step="1" value="5">

      <label for="columns-select">Posters Per Row</label>
      <select id="columns-select">
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>

      <label for="titlecard-columns-select">Titlecards Per Row</label>
      <select id="titlecard-columns-select">
        <option value="2">2</option>
        <option value="3" selected>3</option>
        <option value="4">4</option>
        <option value="5">5</option>
      </select>

      <label for="logo-scale">Logo Scale</label>
      <input type="range" id="logo-scale" min="0.3" max="2" step="0.1" value="1">

      <label for="bg-start">Background Start</label>
      <input type="color" id="bg-start" value="#2c3e50">

      <label for="bg-end">Background End</label>
      <input type="color" id="bg-end" value="#6a11cb">

      <label for="logo-upload" class="drop-zone">Upload Clear Logo</label>
      <input type="file" id="logo-upload" accept="image/*" />

      <label for="file-input" class="drop-zone">Upload Posters</label>
      <input type="file" id="file-input" multiple accept="image/*" />

      <label for="titlecard-input" class="drop-zone">Upload Titlecards</label>
      <input type="file" id="titlecard-input" multiple accept="image/*" />

      <button id="downloadBtn">Download Poster Wall</button>
      <button id="resetBtn">Reset Form</button>
    </div>

    <div class="main">
      <div id="export-wrapper">
	    <div id="export-bg-container">
          <img id="export-background-image" />
        </div>
        <img id="logo-preview" alt="Clear Logo" />

        <h2 class="section-title">Posters</h2>
        <div id="poster-grid-wrapper" class="grid-section">
          <div id="poster-grid"></div>
        </div>

        <hr style="width: 100%; border-color: rgba(255,255,255,0.2);">

        <h2 class="section-title">Titlecards</h2>
        <div id="titlecard-grid-wrapper" class="grid-section">
          <div id="titlecard-grid"></div>
        </div>

        <div class="set-id-line" id="set-id-line"></div>
        <div class="credit-line">
          <div class="created-by" id="created-by">
            <img id="creator-icon" src="" alt="Creator Icon" />
            <span>Created by <span id="credit-text"></span></span>
          </div>
          <div class="powered-by">
            <span>Powered by mediux.pro</span>
            <img src="../assets/mediux.svg" alt="Mediux Icon" />
          </div>
        </div>
      </div>
    </div>
  </div>
		
  <div id="custom-confirm-overlay">
    <div id="custom-confirm-modal">
      <p>Are you sure you want to reset the form? You will lose all current uploads and settings.</p>
      <div class="custom-confirm-buttons">
        <button id="confirmYes">Yes</button>
        <button id="confirmNo">No</button>
      </div>
    </div>
  </div>

<script>
// JavaScript - Full implementation
document.getElementById("creator-icon-upload").addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (evt) => {
      const icon = document.getElementById("creator-icon");
      icon.src = evt.target.result;
      icon.style.display = "inline-block";
    };
    reader.readAsDataURL(file);
  }
});

document.getElementById("creator-name").addEventListener("input", e => {
  document.getElementById("credit-text").textContent = e.target.value;
});
	
const posterGrid = document.getElementById("poster-grid");
const titlecardGrid = document.getElementById("titlecard-grid");
const columnsSelect = document.getElementById("columns-select");
const titlecardColumnsSelect = document.getElementById("titlecard-columns-select");
const bgImage = document.getElementById("export-background-image");
let originalBgDataURL = null;
let blurredBackdropDataURL = null;
let backdropCanvas = document.createElement('canvas');
let backdropCtx = backdropCanvas.getContext('2d');

function groupIntoRows(items, perRow) {
  const rows = [];
  for (let i = 0; i < items.length; i += perRow) {
    const row = document.createElement("div");
    row.className = "row";
    row.append(...items.slice(i, i + perRow));
    rows.push(row);
  }
  return rows;
}

function renderGrid(container, items, perRow) {
  container.innerHTML = "";
  groupIntoRows(items, perRow).forEach(row => container.appendChild(row));
}

function collectItems(gridClass) {
  return [...document.querySelectorAll(`.${gridClass}`)].map(el => el.closest(`.${gridClass}-wrapper`));
}

function groupItemsWithHeaders(container, perRow) {
  const elements = Array.from(container.querySelectorAll('.season-header, .titlecard-wrapper'));
  container.innerHTML = '';

  let currentRow = null, count = 0;

  elements.forEach((el, index) => {
    if (el.classList.contains('season-header')) {
      if (currentRow && currentRow.children.length > 0) {
        container.appendChild(currentRow);
        currentRow = null;
        count = 0;
      }
      
      // Add divider before every header except the first one
      if (index !== 0) {
        const divider = document.createElement('hr');
        divider.style.cssText = 'width: 100%; border-color: rgba(255,255,255,0.2); margin: 10px 0;';
        container.appendChild(divider);
      }

      container.appendChild(el);
    } else {
      if (!currentRow || count >= perRow) {
        if (currentRow) container.appendChild(currentRow);
        currentRow = document.createElement('div');
        currentRow.className = 'row';
        count = 0;
      }
      currentRow.appendChild(el);
      count++;
    }
  });

  if (currentRow && currentRow.children.length > 0) {
    container.appendChild(currentRow);
  }
}

function rebuildGrids() {
  const posterItems = collectItems("poster");
  renderGrid(posterGrid, posterItems, parseInt(columnsSelect.value));

  groupItemsWithHeaders(titlecardGrid, parseInt(titlecardColumnsSelect.value));
}

function createImageElement(src, className) {
  const wrapper = document.createElement("div");
  wrapper.className = `${className}-wrapper`;
  const img = document.createElement("img");
  img.src = src;
  img.className = className;
  img.draggable = true;

  const btn = document.createElement("button");
  btn.className = "delete-btn";
  btn.textContent = "×";
  btn.onclick = () => {
    wrapper.remove();
    rebuildGrids();
  };

  wrapper.appendChild(img);
  wrapper.appendChild(btn);
  img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
  img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
  wrapper.addEventListener("dragover", e => e.preventDefault());
  wrapper.addEventListener("drop", e => {
    e.preventDefault();
    const dragging = document.querySelector("[data-dragging]");
    if (dragging && dragging !== wrapper) {
      wrapper.parentNode.insertBefore(dragging.closest(`.${className}-wrapper`), wrapper);
      rebuildGrids();
    }
  });

  return wrapper;
}

async function handleFiles(files, className) {
  const fileArray = [...files];

  if (className === "poster") {
    fileArray.sort((a, b) => {
      const normalize = name => name.toLowerCase().replace(/\.[^/.]+$/, "").trim();
      const getSortKey = (filename) => {
        const name = normalize(filename.name);
        const seasonMatch = name.match(/ - season (\d{1,3})$/i);
        const baseName = name.replace(/ - season \d{1,3}$/i, "");
        const seasonNumber = seasonMatch ? parseInt(seasonMatch[1], 10) : -1;
        return { baseName, seasonNumber };
      };
      const aKey = getSortKey(a);
      const bKey = getSortKey(b);
      if (aKey.baseName !== bKey.baseName) {
        return aKey.baseName.localeCompare(bKey.baseName);
      }
      return aKey.seasonNumber - bKey.seasonNumber;
    });
  }

  if (className === "titlecard") {
    const parseInfo = name => {
      const cleaned = name.toLowerCase().replace(/\.[^/.]+$/, "").trim();
      const match = cleaned.match(/s(\d{1,2})[\s\.]?e(\d{1,2})/i);
      const season = match ? parseInt(match[1], 10) : 0;
      const episode = match ? parseInt(match[2], 10) : 0;
      return { name, season, episode };
    };

    const container = document.querySelector(`#${className}-grid`);

    // Extract existing titlecards first
    const existingWrappers = Array.from(container.querySelectorAll('.titlecard-wrapper'));
    const existingCards = existingWrappers.map(wrapper => ({
      src: wrapper.querySelector('img').src,
      season: parseInt(wrapper.dataset.season),
      episode: parseInt(wrapper.dataset.episode),
    }));

    // Process new uploaded titlecards
    const newCards = await Promise.all(fileArray.map(async file => {
      const src = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(file);
      });
      const {season, episode} = parseInfo(file.name);
      return {src, season, episode};
    }));

    // Merge and sort existing + new titlecards
    const allCards = [...existingCards, ...newCards].sort((a, b) =>
      a.season - b.season || a.episode - b.episode
    );

    // Clear container for fresh regrouping
    container.innerHTML = '';

    let currentSeason = null;

    // Rebuild titlecards with headers
    allCards.forEach(card => {
      if (card.season !== currentSeason) {
        currentSeason = card.season;
        const heading = document.createElement("div");
        heading.className = "season-header";
        heading.textContent = `Season ${String(card.season).padStart(2, '0')}`;
        container.appendChild(heading);
      }

      const wrapper = document.createElement("div");
      wrapper.className = "titlecard-wrapper";
      wrapper.dataset.season = card.season;
      wrapper.dataset.episode = card.episode;

      const img = document.createElement("img");
      img.src = card.src;
      img.className = "titlecard";
      img.draggable = true;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "×";
      btn.onclick = () => {
        wrapper.remove();
        rebuildGrids();
      };

      wrapper.appendChild(img);
      wrapper.appendChild(btn);

      img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
      img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
      wrapper.addEventListener("dragover", e => e.preventDefault());
      wrapper.addEventListener("drop", e => {
        e.preventDefault();
        const dragging = document.querySelector("[data-dragging]");
        if (dragging && dragging !== wrapper) {
          wrapper.parentNode.insertBefore(dragging.closest('.titlecard-wrapper'), wrapper);
          rebuildGrids();
        }
      });

      container.appendChild(wrapper);
    });

    // Final regroup into rows
    groupItemsWithHeaders(container, parseInt(titlecardColumnsSelect.value));

  } else {
    // For posters (original logic remains)
    const container = document.querySelector(`#${className}-grid`);
    container.innerHTML = "";

    const wrappers = await Promise.all(fileArray.map(async file => {
      const result = await new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => resolve(e.target.result);
        reader.readAsDataURL(file);
      });

      const wrapper = document.createElement("div");
      wrapper.className = `${className}-wrapper`;

      const img = document.createElement("img");
      img.src = result;
      img.className = className;
      img.draggable = true;

      const btn = document.createElement("button");
      btn.className = "delete-btn";
      btn.textContent = "×";
      btn.onclick = () => {
        wrapper.remove();
        rebuildGrids();
      };

      wrapper.appendChild(img);
      wrapper.appendChild(btn);

      img.addEventListener("dragstart", () => wrapper.dataset.dragging = true);
      img.addEventListener("dragend", () => delete wrapper.dataset.dragging);
      wrapper.addEventListener("dragover", e => e.preventDefault());
      wrapper.addEventListener("drop", e => {
        e.preventDefault();
        const dragging = document.querySelector("[data-dragging]");
        if (dragging && dragging !== wrapper) {
          wrapper.parentNode.insertBefore(dragging.closest(`.${className}-wrapper`), wrapper);
          rebuildGrids();
        }
      });

      return wrapper;
    }));

    wrappers.forEach(wrapper => container.appendChild(wrapper));
    rebuildGrids();
  }
}

document.getElementById("backdrop-upload").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async (evt) => {
    const dataURL = evt.target.result;
    
    try {
      // Store original image data for later use
      const originalImg = new Image();
      originalImg.src = dataURL;
      
      await new Promise(resolve => {
        originalImg.onload = resolve;
      });
      
      window._originalBackdropImage = originalImg;
      
      // Apply blur with current slider value
      const blurAmount = parseInt(document.getElementById("blur-amount").value);
      applySmartBlur(originalImg, blurAmount);
      
    } catch (error) {
      console.error("Error in backdrop processing:", error);
      alert("There was an error processing your image. Please try another one.");
    }
  };
  
  reader.readAsDataURL(file);
  e.target.value = "";
});

document.getElementById("blur-amount").addEventListener("input", async (e) => {
  if (!window._originalBackdropImage) return;
  
  const blurAmount = parseInt(e.target.value);
  applySmartBlur(window._originalBackdropImage, blurAmount);
});

function applySmartBlur(originalImg, blurAmount) {
  // Create a canvas for processing
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas to a reasonable size (not too small to avoid excessive pixelation)
  const scaleFactor = Math.max(0.1, 1 - (blurAmount * 0.03)); // Smoother scale reduction
  
  canvas.width = Math.floor(originalImg.width * scaleFactor);
  canvas.height = Math.floor(originalImg.height * scaleFactor);
  
  // First pass - draw at reduced size (creates initial blur)
  ctx.drawImage(originalImg, 0, 0, canvas.width, canvas.height);
  
  // Apply a CSS-style blur filter if blurAmount is high enough
  if (blurAmount > 5) {
    // This simulates a Gaussian blur
    const blurPx = Math.min(20, blurAmount - 5);
    ctx.filter = `blur(${blurPx}px)`;
    ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
    ctx.filter = 'none';
  }
  
  // Calculate dimensions with padding to ensure coverage to edges
  const padding = 50; // Add extra padding to ensure full coverage
  
  // Second pass - scale back up with padding
  const finalCanvas = document.createElement('canvas');
  const finalCtx = finalCanvas.getContext('2d');
  
  // Use a size that matches the aspect ratio but is reasonably large
  const maxDimension = Math.max(originalImg.width, originalImg.height);
  const targetSize = Math.min(1920, maxDimension); // Cap at 1920px for performance
  
  let finalWidth, finalHeight;
  if (originalImg.width > originalImg.height) {
    finalWidth = targetSize + padding * 2;
    finalHeight = ((originalImg.height / originalImg.width) * targetSize) + padding * 2;
  } else {
    finalHeight = targetSize + padding * 2;
    finalWidth = ((originalImg.width / originalImg.height) * targetSize) + padding * 2;
  }
  
  finalCanvas.width = finalWidth;
  finalCanvas.height = finalHeight;
  
  // Use better quality interpolation
  finalCtx.imageSmoothingEnabled = true;
  finalCtx.imageSmoothingQuality = "high";
  
  // Draw the blurred image at larger size with padding
  finalCtx.drawImage(canvas, -padding, -padding, finalWidth + padding * 2, finalHeight + padding * 2);
  
  // Add a subtle darkening overlay to make content stand out better
  finalCtx.fillStyle = "rgba(0, 0, 0, 0.2)";
  finalCtx.fillRect(0, 0, finalWidth, finalHeight);
  
  // Apply the blurred image as background
  const blurredDataURL = finalCanvas.toDataURL('image/jpeg', 0.92);
  blurredBackdropDataURL = blurredDataURL;
  window._currentBackdropURL = blurredDataURL;
  
  // Apply to the export wrapper with adjusted background properties
  const exportWrapper = document.getElementById("export-wrapper");
  
  // Update ALL background properties to ensure proper coverage
  exportWrapper.style.background = "none";
  exportWrapper.style.backgroundImage = `url('${blurredDataURL}')`;
  exportWrapper.style.backgroundSize = "110% 110%"; // Slightly larger than container
  exportWrapper.style.backgroundPosition = "center center";
  exportWrapper.style.backgroundRepeat = "no-repeat";
  
  // Hide regular background
  const bgContainer = document.getElementById("export-bg-container");
  if (bgContainer) {
    bgContainer.style.display = "none";
  }
}

document.getElementById("file-input").addEventListener("change", async (e) => {
  await handleFiles(e.target.files, "poster");
});

document.getElementById("titlecard-input").addEventListener("change", async (e) => {
  await handleFiles(e.target.files, "titlecard");
});
columnsSelect.addEventListener("change", rebuildGrids);
titlecardColumnsSelect.addEventListener("change", rebuildGrids);

document.getElementById("creator-name").addEventListener("input", e => {
  document.getElementById("credit-text").textContent = e.target.value;
});
document.getElementById("set-id").addEventListener("input", e => {
  document.getElementById("set-id-line").textContent = e.target.value ? `Set ID: ${e.target.value}` : "";
});
document.getElementById("logo-scale").addEventListener("input", e => {
  document.getElementById("logo-preview").style.transform = `scale(${e.target.value})`;
});
document.getElementById("logo-upload").addEventListener("change", e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    const img = document.getElementById("logo-preview");
    img.src = evt.target.result;
    img.style.display = "block";
  };
  reader.readAsDataURL(file);
});

document.getElementById("bg-start").addEventListener("input", e => {
  document.getElementById("export-wrapper").style.setProperty("--bg-start", e.target.value);
  updateBackgroundStyles();
});
document.getElementById("bg-end").addEventListener("input", e => {
  document.getElementById("export-wrapper").style.setProperty("--bg-end", e.target.value);
  updateBackgroundStyles();
});

function updateBackgroundStyles() {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgContainer = document.getElementById("export-bg-container");

  // If we have a blurred backdrop, it takes priority
  if (window._currentBackdropURL) {
    bgContainer.style.display = "none";
    exportWrapper.style.background = "none";
    exportWrapper.style.backgroundImage = `url(${window._currentBackdropURL})`;
    exportWrapper.style.backgroundSize = "cover";
    exportWrapper.style.backgroundPosition = "center";
    return;
  }

  if (originalBgDataURL) {
    bgContainer.style.display = "block";
    exportWrapper.style.background = "none"; // override gradient fallback
  } else {
    bgContainer.style.display = "none";
    const bgStart = document.getElementById("bg-start").value;
    const bgEnd = document.getElementById("bg-end").value;
    exportWrapper.style.background = `linear-gradient(135deg, ${bgStart}, ${bgEnd})`;
  }
}

function fixBackgroundContainerSizing() {
  const exportWrapper = document.getElementById("export-wrapper");
  const bgContainer = document.getElementById("export-bg-container");
  
  if (exportWrapper && bgContainer) {
    // Make sure the background container completely fills the wrapper
    bgContainer.style.position = "absolute";
    bgContainer.style.top = "0";
    bgContainer.style.left = "0";
    bgContainer.style.right = "0";
    bgContainer.style.bottom = "0";
    bgContainer.style.overflow = "hidden";
    bgContainer.style.borderRadius = "12px"; // Match wrapper's border radius
    bgContainer.style.margin = "0"; // Remove any margin
    
    // Make sure any white borders or outlines are removed
    exportWrapper.style.border = "none";
    exportWrapper.style.outline = "none";
    exportWrapper.style.overflow = "hidden"; // Prevent content from spilling out
  }
  
  // Do the same for backdrop container if it exists
  const backdropContainer = document.getElementById("backdrop-container");
  if (exportWrapper && backdropContainer) {
    backdropContainer.style.position = "absolute";
    backdropContainer.style.top = "0";
    backdropContainer.style.left = "0";
    backdropContainer.style.right = "0";
    backdropContainer.style.bottom = "0";
    backdropContainer.style.overflow = "hidden";
    backdropContainer.style.borderRadius = "12px";
    backdropContainer.style.margin = "0";
  }
}

async function blurImage(img, blurAmount) {
  return new Promise((resolve, reject) => {
    try {
      // Set canvas dimensions to match image
      backdropCanvas.width = img.width;
      backdropCanvas.height = img.height;
      
      // Clear canvas
      backdropCtx.clearRect(0, 0, backdropCanvas.width, backdropCanvas.height);
      
      // Draw the original image
      backdropCtx.drawImage(img, 0, 0);
      
      // Apply stack blur algorithm - multiply the blur amount to make it stronger
      // Change this line:
      if (blurAmount > 0) {
        // Apply the blur multiple times for stronger effect
        const enhancedBlur = Math.min(blurAmount * 3, 150); // Limit max blur to 150px
        stackBlur(backdropCtx, 0, 0, backdropCanvas.width, backdropCanvas.height, enhancedBlur);
      }
      
      // Return the blurred image data URL
      resolve(backdropCanvas.toDataURL('image/jpeg', 0.85));
    } catch (error) {
      reject(error);
    }
  });
}
// Function to check if sidebar needs scrolling
function checkSidebarScroll() {
  const sidebar = document.querySelector('.sidebar');
  const layout = document.querySelector('.layout');
  
  // If sidebar content is taller than the available height
  if (sidebar.scrollHeight > layout.clientHeight) {
    sidebar.classList.add('scrollable');
  } else {
    sidebar.classList.remove('scrollable');
  }
}

// Call these functions on page load
fixBackgroundContainerSizing();
updateBackgroundStyles();
checkSidebarScroll();

// Also call after relevant changes
window.addEventListener("resize", () => {
  fixBackgroundContainerSizing();
  checkSidebarScroll();
});

document.getElementById("resetBtn").addEventListener("click", () => {
  const overlay = document.getElementById('custom-confirm-overlay');
  const confirmYes = document.getElementById('confirmYes');
  const confirmNo = document.getElementById('confirmNo');

  overlay.style.display = 'flex';

  confirmYes.onclick = () => location.reload();
  confirmNo.onclick = () => overlay.style.display = 'none';
});

// Stack Blur Algorithm by Mario Klingemann <mario@quasimondo.com>
// http://www.quasimondo.com/StackBlurForCanvas/StackBlurDemo.html
function stackBlur(ctx, x, y, width, height, radius) {
  if (radius < 1) return;
  
  var imgData = ctx.getImageData(x, y, width, height);
  var pixels = imgData.data;
  
  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
      r_out_sum, g_out_sum, b_out_sum, a_out_sum,
      r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
      pr, pg, pb, pa, rbs;
      
  var div = radius + radius + 1;
  var widthMinus1  = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1  = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  
  var stackStart = new BlurStack();
  var stack = stackStart;
  for (i = 1; i < div; i++) {
    stack = stack.next = new BlurStack();
    if (i == radiusPlus1) var stackEnd = stack;
  }
  stack.next = stackStart;
  var stackIn = null;
  var stackOut = null;
  
  yw = yi = 0;
  
  var mul_sum = mul_table[radius];
  var shg_sum = shg_table[radius];
  
  for (y = 0; y < height; y++) {
    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
    
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi+3]);
    
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    
    stack = stackStart;
    
    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    
    for (i = 1; i < radiusPlus1; i++) {
      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
      r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[p+1])) * rbs;
      b_sum += (stack.b = (pb = pixels[p+2])) * rbs;
      a_sum += (stack.a = (pa = pixels[p+3])) * rbs;
      
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      
      stack = stack.next;
    }
    
    stackIn = stackStart;
    stackOut = stackEnd;
    for (x = 0; x < width; x++) {
      pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
      if (pa != 0) {
        pa = 255 / pa;
        pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
      }
      
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      
      p =  (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
      
      r_in_sum += (stackIn.r = pixels[p]);
      g_in_sum += (stackIn.g = pixels[p+1]);
      b_in_sum += (stackIn.b = pixels[p+2]);
      a_in_sum += (stackIn.a = pixels[p+3]);
      
      r_sum += r_in_sum;
      g_sum += g_in_sum;
      b_sum += b_in_sum;
      a_sum += a_in_sum;
      
      stackIn = stackIn.next;
      
      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);
      a_out_sum += (pa = stackOut.a);
      
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      
      stackOut = stackOut.next;

      yi += 4;
    }
    yw += width;
  }
  
  for (x = 0; x < width; x++) {
    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
    
    yi = x << 2;
    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
    g_out_sum = radiusPlus1 * (pg = pixels[yi+1]);
    b_out_sum = radiusPlus1 * (pb = pixels[yi+2]);
    a_out_sum = radiusPlus1 * (pa = pixels[yi+3]);
    
    r_sum += sumFactor * pr;
    g_sum += sumFactor * pg;
    b_sum += sumFactor * pb;
    a_sum += sumFactor * pa;
    
    stack = stackStart;
    
    for (i = 0; i < radiusPlus1; i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    
    yp = width;
    
    for (i = 1; i <= radius; i++) {
      yi = (yp + x) << 2;
      
      r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
      g_sum += (stack.g = (pg = pixels[yi+1])) * rbs;
      b_sum += (stack.b = (pb = pixels[yi+2])) * rbs;
      a_sum += (stack.a = (pa = pixels[yi+3])) * rbs;
      
      r_in_sum += pr;
      g_in_sum += pg;
      b_in_sum += pb;
      a_in_sum += pa;
      
      stack = stack.next;
    
      if (i < heightMinus1) {
        yp += width;
      }
    }
    
    yi = x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (y = 0; y < height; y++) {
      p = yi << 2;
      pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
      if (pa > 0) {
        pa = 255 / pa;
        pixels[p]   = ((r_sum * mul_sum) >> shg_sum) * pa;
        pixels[p+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
        pixels[p+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
      } else {
        pixels[p] = pixels[p+1] = pixels[p+2] = 0;
      }
      
      r_sum -= r_out_sum;
      g_sum -= g_out_sum;
      b_sum -= b_out_sum;
      a_sum -= a_out_sum;
      
      r_out_sum -= stackIn.r;
      g_out_sum -= stackIn.g;
      b_out_sum -= stackIn.b;
      a_out_sum -= stackIn.a;
      
      p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;
      
      r_sum += (r_in_sum += (stackIn.r = pixels[p]));
      g_sum += (g_in_sum += (stackIn.g = pixels[p+1]));
      b_sum += (b_in_sum += (stackIn.b = pixels[p+2]));
      a_sum += (a_in_sum += (stackIn.a = pixels[p+3]));
      
      stackIn = stackIn.next;
      
      r_out_sum += (pr = stackOut.r);
      g_out_sum += (pg = stackOut.g);
      b_out_sum += (pb = stackOut.b);
      a_out_sum += (pa = stackOut.a);
      
      r_in_sum -= pr;
      g_in_sum -= pg;
      b_in_sum -= pb;
      a_in_sum -= pa;
      
      stackOut = stackOut.next;
      
      yi += width;
    }
  }
  
  ctx.putImageData(imgData, x, y);
}

// BlurStack class needed for the blur algorithm
function BlurStack() {
  this.r = 0;
  this.g = 0;
  this.b = 0;
  this.a = 0;
  this.next = null;
}

// Lookup tables for blur algorithm
var mul_table = [
  512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
  454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
  482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
  437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
  497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
  320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
  446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
  329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
  505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
  399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
  324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
  268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
  451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
  385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
  332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
  289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
];

var shg_table = [
  9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
  17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
  19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
  20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
  21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
  22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
  22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
  23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
  23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
];

document.getElementById("downloadBtn").addEventListener("click", async () => {
  const wrapper = document.getElementById("export-wrapper");
  const borderRadius = 24; // Border radius value in pixels (for export)
  
  // Check for blurred backdrop
  const hasBlurredBackdrop = window._currentBackdropURL ? true : false;
  const originalBg = originalBgDataURL; // Custom background image
  
  // Clone the wrapper to avoid modifying the actual DOM
  const clone = wrapper.cloneNode(true);
  clone.querySelectorAll(".delete-btn").forEach(btn => btn.remove());
  
  // Set proper styles for the clone
  clone.style.borderRadius = `${borderRadius}px`;
  clone.style.overflow = "hidden";
  
  // IMPORTANT: Completely strip background from clone - we'll draw it manually
  clone.style.background = "none";
  clone.style.backgroundColor = "transparent";
  clone.style.backgroundImage = "none";
  
  // Also clean the export-wrapper inside the clone
  const cloneExportWrapper = clone.querySelector("#export-wrapper");
  if (cloneExportWrapper) {
    cloneExportWrapper.style.borderRadius = `${borderRadius}px`;
    cloneExportWrapper.style.overflow = "hidden";
    cloneExportWrapper.style.background = "none";
    cloneExportWrapper.style.backgroundColor = "transparent";
    cloneExportWrapper.style.backgroundImage = "none";
  }
  
  // Remove ALL background containers from clone
  const bgContainerClone = clone.querySelector("#export-bg-container");
  if (bgContainerClone) bgContainerClone.remove();
  
  const backdropContainerClone = clone.querySelector("#backdrop-container");
  if (backdropContainerClone) backdropContainerClone.remove();

  // Remove titlecard section if empty
  const titlecardGridClone = clone.querySelector("#titlecard-grid");
  if (!titlecardGridClone || titlecardGridClone.children.length === 0) {
    const sectionTitle = clone.querySelector(".section-title:nth-of-type(2)");
    const wrapper = clone.querySelector("#titlecard-grid-wrapper");
    if (sectionTitle) sectionTitle.remove();
    if (wrapper) wrapper.remove();
  }

  // Position clone off-screen for rendering
  clone.style.position = "absolute";
  clone.style.left = "-9999px";
  document.body.appendChild(clone);

  await new Promise(requestAnimationFrame); // wait for DOM paint

  // Capture ONLY the content (no background)
  const contentCanvas = await html2canvas(clone, {
    scale: 2,
    backgroundColor: null, // Transparent background is crucial
    logging: false,
    onclone: (document) => {
      // Double-ensure no backgrounds on any elements
      const exportWrapper = document.getElementById("export-wrapper");
      if (exportWrapper) {
        exportWrapper.style.background = "none";
        exportWrapper.style.backgroundColor = "transparent";
        exportWrapper.style.backgroundImage = "none";
      }
    }
  });

  document.body.removeChild(clone);

  // Create final canvas with correct dimensions
  const finalCanvas = document.createElement("canvas");
  finalCanvas.width = contentCanvas.width;
  finalCanvas.height = contentCanvas.height;
  const ctx = finalCanvas.getContext("2d");

  // Apply rounded corners via clipping path
  const scaledRadius = borderRadius * 2;
  ctx.beginPath();
  ctx.moveTo(scaledRadius, 0);
  ctx.lineTo(finalCanvas.width - scaledRadius, 0);
  ctx.quadraticCurveTo(finalCanvas.width, 0, finalCanvas.width, scaledRadius);
  ctx.lineTo(finalCanvas.width, finalCanvas.height - scaledRadius);
  ctx.quadraticCurveTo(finalCanvas.width, finalCanvas.height, finalCanvas.width - scaledRadius, finalCanvas.height);
  ctx.lineTo(scaledRadius, finalCanvas.height);
  ctx.quadraticCurveTo(0, finalCanvas.height, 0, finalCanvas.height - scaledRadius);
  ctx.lineTo(0, scaledRadius);
  ctx.quadraticCurveTo(0, 0, scaledRadius, 0);
  ctx.closePath();
  ctx.clip();

  // Step 1: Draw the appropriate background covering the ENTIRE canvas
  if (hasBlurredBackdrop && window._currentBackdropURL) {
    // Use blurred backdrop
    const bgImg = new Image();
    await new Promise((resolve, reject) => {
      bgImg.onload = resolve;
      bgImg.onerror = reject;
      bgImg.src = window._currentBackdropURL;
    });

    // Fill the entire canvas with the blurred backdrop
    ctx.drawImage(bgImg, 0, 0, finalCanvas.width, finalCanvas.height);
    
    // Add slight darkening overlay for better contrast with content
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
    ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
  }
  else if (originalBg) {
    // Use regular background image
    const bgImg = new Image();
    await new Promise((resolve, reject) => {
      bgImg.onload = resolve;
      bgImg.onerror = reject;
      bgImg.src = originalBg;
    });

    ctx.drawImage(bgImg, 0, 0, finalCanvas.width, finalCanvas.height);
  } else {
    // Fallback to gradient
    const gradient = ctx.createLinearGradient(0, 0, finalCanvas.width, finalCanvas.height);
    gradient.addColorStop(0, getComputedStyle(wrapper).getPropertyValue('--bg-start') || '#2c3e50');
    gradient.addColorStop(1, getComputedStyle(wrapper).getPropertyValue('--bg-end') || '#6a11cb');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
  }
  
  // Step 2: Draw the content (posters, titlecards, etc.) on top
  ctx.drawImage(contentCanvas, 0, 0);
  
  // Step 3: Export as image
  const link = document.createElement("a");
  link.download = "poster-wall.png";
  link.href = finalCanvas.toDataURL("image/png");
  link.click();
});
</script>
</body>
</html>
